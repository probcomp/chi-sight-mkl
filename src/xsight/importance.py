# AUTOGENERATED! DO NOT EDIT! File to edit: ../../notebooks/99 - Importance Sampling.ipynb.

# %% auto 0
__all__ = ['logsumexp', 'vmap', 'keysplit']

# %% ../../notebooks/99 - Importance Sampling.ipynb 2
import genjax
from genjax import gen
import jax.numpy as jnp
import jax
from jax import jit, vmap

# %% ../../notebooks/99 - Importance Sampling.ipynb 4
def keysplit(key, *ns):
    if len(ns) == 0:
        return jax.random.split(key, 1)[0]
    
    if len(ns) == 1:
        return jax.random.split(key, ns[0])
    else:

        keys = []
        for n in ns:
            if n == 1: keys.append(jax.random.split(key, 1)[0])
            else: keys.append(jax.random.split(key, n))

        return keys

# %% ../../notebooks/99 - Importance Sampling.ipynb 5
logsumexp = jax.scipy.special.logsumexp
vmap      = jax.vmap

# %% ../../notebooks/99 - Importance Sampling.ipynb 6
#
# Gen.jl style ordering of the args and return values
#
def _merge(x,y): return x.merge(y)


def _update(key, tr, argdiffs, ch):
    retdiff, w, tr_, discard = tr.update(key, ch, argdiffs)
    return tr_, w, retdiff, discard


def _simulate(key, model, args):
    return model.simulate(key, args)


def _propose(key, model, args):
    tr = model.simulate(key, args)
    # Note: `strip` returns a stripped choice map
    return (tr.strip(), tr.get_score(), tr.get_retval())


def _generate(key, model, args, constr):
    (w, tr) = model.importance(key, constr, args)
    return (tr, w)


def _importance_sampling(key, 
                        model, args, obs, 
                        proposal, proposal_args,   
                        N:int):
    """
    Importance sampling with custom proposal 

    Usage:
    ```python

        N = 100
        _importance_sampling_jit = jit(partial(_importance_sampling, N=N))
        key, (trs, ws, lml) = _importance_sampling_jit(key, model, args, obs, prop, prop_args)

    ```
    """


    # Get some proposed choices
    key, keys = keysplit(key,1,N)
    (prop_ch, prop_ws, _) = vmap(_propose, (0, None, None))(
        keys, proposal, proposal_args)
    
    # Merge observations and proposal choices
    constr, _ = vmap(_merge, (0,None))(prop_ch, obs)

    # Generate new traces given these new constraints
    key, keys = keysplit(key,1,N)
    (trs, ws) = vmap(_generate, in_axes=(0,None,None,0))(
        keys, model, args, constr)
    
    # Adjust the importance weights accordingly
    ws    = ws - prop_ws
    total = logsumexp(ws)
    ws    = ws - total          # Log normalize
    lml   = total - jnp.log(N)  # Estimate of the (log) marginal likelihood

    return (trs, ws, lml)


