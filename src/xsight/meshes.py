# AUTOGENERATED! DO NOT EDIT! File to edit: ../../notebooks/03 - Meshes.ipynb.

# %% auto 0
__all__ = ['cube', 'pyramid', 'table', 'mesh', 'MP_CAM_VIEW', 'MP_WORLD_VIEW', 'create_cuboid', 'create_box', 'create_cube',
           'create_sphere', 'create_pyramid', 'move_to_xy', 'move_to_z', 'mp_plot_pose', 'Viewer',
           'trimesh_from_2d_segs', 'load_env_data', 'unpack_2d_env_data']

# %% ../../notebooks/03 - Meshes.ipynb 2
import warnings
warnings.filterwarnings('ignore')
import trimesh
import numpy as np
import jax.numpy as jnp
from pathlib import Path
import pythreejs as p3s

from .pose import pack_pose, lift_pose, unpack_pose, look_at, from_euler

# %% ../../notebooks/03 - Meshes.ipynb 3
def create_cuboid(width=1., height=1., depth=1.):
    vertices = [
        [0, 0, 0],               # Vertex 0 (bottom-front-left)
        [width, 0, 0],           # Vertex 1 (bottom-front-right)
        [width, height, 0],      # Vertex 2 (top-front-right)
        [0, height, 0],          # Vertex 3 (top-front-left)
        [0, 0, depth],           # Vertex 4 (bottom-back-left)
        [width, 0, depth],       # Vertex 5 (bottom-back-right)
        [width, height, depth],  # Vertex 6 (top-back-right)
        [0, height, depth]       # Vertex 7 (top-back-left)
    ]
    faces = [
        [0, 1, 2, 3],  # Front face
        [1, 5, 6, 2],  # Right face
        [5, 4, 7, 6],  # Back face
        [4, 0, 3, 7],  # Left face
        [3, 2, 6, 7],  # Top face
        [4, 5, 1, 0]   # Bottom face
    ]

    cuboid_mesh = trimesh.Trimesh(vertices=vertices, faces=faces, process=False)
    cuboid_mesh.fix_normals()

    return cuboid_mesh


def create_box(width=1., height=1., depth=1.):
    b = trimesh.primitives.Box(extents=(width, height, depth), transform=None, bounds=None, mutable=True)
    return b.vertices, b.faces

def create_cube(size=1.):
    return create_box(size, size, size)

def create_sphere(radius=1.0, subdivisions=0):
    s = trimesh.primitives.Sphere(radius=radius, center=np.zeros(3), subdivisions=subdivisions)
    return s.vertices, s.faces

# %% ../../notebooks/03 - Meshes.ipynb 4
def create_pyramid(width=1.,height=1.,depth=1.):
    w,h,d = width,height,depth
    vertices = [
        [0, 0, 0],  # Base vertex 1
        [w, 0, 0],  # Base vertex 2
        [w, h, 0],  # Base vertex 3
        [0, h, 0],  # Base vertex 4
        [w/2, h/2, d]  # Apex vertex
    ]
    faces = [
        [0, 2, 1],  # Base face 1 (reversed order)
        [0, 3, 2],  # Base face 2 (reversed order)
        [0, 1, 4],  # Side face 1
        [1, 2, 4],  # Side face 2
        [2, 3, 4],  # Side face 3
        [3, 0, 4]   # Side face 4
    ]

    mesh = trimesh.Trimesh(vertices=vertices, faces=faces)
    mesh.fix_normals()
    return mesh

# %% ../../notebooks/03 - Meshes.ipynb 5
def move_to_xy(mesh, x, y):
    current_center = (np.min(mesh.vertices, axis=0) + np.max(mesh.vertices, axis=0))/2
    translation    = [x - current_center[0], y - current_center[1], 0]
    mesh_ = mesh.copy()
    mesh_.vertices += translation

    return mesh_


def move_to_z(mesh, z):
    translation = [0, 0, z - np.min(mesh.vertices[:,2])]
    mesh_ = mesh.copy()
    mesh_.vertices += translation

    return mesh_


# %% ../../notebooks/03 - Meshes.ipynb 8
cube    = create_cuboid()
pyramid = create_pyramid()
table   = create_cuboid(10, 10, -0.1)

cube    = move_to_xy(cube, 1, 1)
pyramid = move_to_xy(pyramid, 0, -1)
table   = move_to_xy(table,0,0)

mesh = trimesh.util.concatenate([
    move_to_xy(cube, 2, 1), 
    move_to_xy(pyramid, 0, 0), 
    move_to_xy(table,0,0)
])

# %% ../../notebooks/03 - Meshes.ipynb 10
import meshplot as mp

def mp_plot_pose(mp_viewer, t, r, scale=1.0, colors=['red', 'green', 'blue'], width=4):
    for dt, c in zip(r.T, colors):
        mp_viewer.add_lines(t[None], (t + dt)[None], 
                         shading=dict(line_width = width, line_color = c));
    return mp_viewer

# %% ../../notebooks/03 - Meshes.ipynb 13
# How a CAMERA coords "naturally" 
# embed into mp viewer coords
MP_CAM_VIEW = np.array([
    [ 1.0,   0.0,  0.0],
    [ 0.0,   1.0,  0.0],
    [ 0.0,   0.0,  -1.0]
])

# MP canonical Camera rotation
MP_WORLD_VIEW = np.array([
    [ 1.0,  0.0,  0.0],
    [ 0.0,  0.0,  1.0],
    [ 0.0,  -1.0,  0.0]
])

# %% ../../notebooks/03 - Meshes.ipynb 16
import meshplot as mp
import numpy as np
#|export
# How a CAMERA coords "naturally" 
# embed into mp viewer coords
MP_CAM_VIEW = np.array([
    [ 1.0,   0.0,  0.0],
    [ 0.0,   1.0,  0.0],
    [ 0.0,   0.0,  -1.0]
])

# MP canonical Camera rotation
MP_WORLD_VIEW = np.array([
    [ 1.0,  0.0,  0.0],
    [ 0.0,  0.0,  1.0],
    [ 0.0,  -1.0,  0.0]
])

class Viewer(object):
    def __init__(self, 
                 width  = 600, 
                 height = 400, 
                 background = "#fff", 
                 fov = 40, 
                 cam_pos  = [0, 0, 10], 
                 cam_look = [0, 0, 0],
                 view_as="world",
                 view=None,
                ):
        
        # Coordinate transform
        # To adjust mp's turntable view.
        self.T = np.eye(3)
        if view is None:
            if view_as == "world": self.T = MP_WORLD_VIEW.T
        else:
            self.T = view.T


        self._v = mp.Viewer({
            "width": width, 
            "height": height, 
            "antialias": True, 
            "scale": 1.0, 
            "background": background, 
            "fov": fov})
        
        # hack to disable auto update
        self._v.__update_view_func = self._v.__update_view
        self._v.__update_view = lambda: None

        self._v._orbit.target = tuple(cam_look@self.T)
        self._v._cam.lookAt(tuple(cam_look@self.T))
        self._v._cam.position = tuple(cam_pos@self.T)
        self._v._orbit.exec_three_obj_method('update')
        self._v._cam.exec_three_obj_method('updateProjectionMatrix')


    def add_mesh(self, vs, fs, c=np.array([1,1,1]), **kwargs):
        kwargs_ = {"shading": {"wireframe": True}}
        kwargs_.update(kwargs)

        
        self._v.add_mesh(vs@self.T, fs, c=c, **kwargs_)

    def add_points(self, vs, c=np.array([[1,1,1]]), s=1.0):
        self._v.add_points(vs@self.T, c=c, shading={"point_size": s})

    def add_pose(self, p, colors=['red', 'green', 'blue'], linewidth=4, scale=1.0):
        x, r = unpack_pose(p)
        x = x@self.T
        for dx, c in zip(r.T, colors):
            self._v.add_lines(x[None], (x + scale*dx@self.T)[None], 
                         shading=dict(line_width = linewidth,linewidth=linewidth, line_color = c));


        return self

        
    def _repr_mimebundle_(self, **kwargs):
        return self._v._renderer._repr_mimebundle_(**kwargs)

    def look_at(self, look):
        self._v._cam.lookAt(tuple(look@self.T))
        # self._v._orbit.target = look
        self._v._orbit.exec_three_obj_method('update')
        self._v._cam.exec_three_obj_method('updateProjectionMatrix')
        return self

    def look_from(self, pos):
        self._v._cam.position = tuple(pos@self.T)
        self._v._cam.exec_three_obj_method('updateProjectionMatrix')
        return self

# %% ../../notebooks/03 - Meshes.ipynb 21
def trimesh_from_2d_segs(segs):
    pieces = []
    for s in segs:
        x = s[:2]
        y = s[2:]

        p = pack_pose(np.concatenate([(x + y)/2 , np.array([0.5])]), np.eye(3))

        dimensions = np.array(np.concatenate([np.abs(x - y) , np.array([1.0])]))
        piece = trimesh.creation.box(dimensions, p)
        pieces.append(piece)

    map_mesh = trimesh.util.concatenate(pieces)
    return map_mesh

# %% ../../notebooks/03 - Meshes.ipynb 22
import json 

def load_env_data(fname):
    with open(fname) as f:
        data = json.load(f)

    return data

def unpack_2d_env_data(fname):
    data = load_env_data(fname)

    segs   = np.array(data["segs"])

    # Convert clutter verts to segs
    clutter = np.array(data["clutter_verts"])
    clutter = data["clutter_verts"]
    clutter = np.array(clutter)
    clutter = np.stack([clutter[:,:-1,:], clutter[:,1:,:]], axis=2)
    clutter = np.concatenate(clutter, axis=0).reshape(-1,4)

    xs  = np.array(data["paths"][0])
    dxs = xs[1:] - xs[:-1]
    hds = np.arctan2(dxs[:, 1], dxs[:, 0])
    dhds = hds[1:] - hds[:-1]
    xs  = xs[:-1]
    T   = len(xs)
    return segs, clutter, xs, hds, dxs[:-1], dhds
